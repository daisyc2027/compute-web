<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Dashboard | SING Cloud | Next-Gen AI Cloud</title>

    <!-- Bluma CSS and Bliss JS-->
    <script src="assets/bliss.js"></script>
    <link rel="stylesheet" href="assets/bulma.min.css">

    <!-- TACC Theme files -->
    <link href="assets/tacc-theme.css" rel="stylesheet">
    <script src="assets/tacc-theme.js"></script>
    <script src="scripts/sing-api.js"></script>
    <script type="module" src="./scripts/sing-theme.js"></script>
    <script type="module" src="./scripts/sing-footer.js"></script>

    <!-- Launch page specific styles -->
    <link href="assets/launch-styles.css" rel="stylesheet">

    <!-- Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap"
        rel="stylesheet">
    <script src="https://kit.fontawesome.com/99d5980073.js" crossorigin="anonymous"></script>

    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/showdown/dist/showdown.min.js"></script>
</head>

<body>
    <sing-navigation></sing-navigation>

    <section class="section form">
        <script>
            document.addEventListener('DOMContentLoaded', function () {
                // Initialize Showdown converter with options
                window.converter = new showdown.Converter({
                    ghCompatible: true,
                    simpleLineBreaks: true,
                    sanitize: false,
                    openLinksInNewWindow: true,
                    smartIndentationFix: true
                });

                // Get metadata container, ensure it's hidden initially
                const metadataContainer = document.getElementById('image-metadata-container');

                if (metadataContainer) {
                    metadataContainer.style.display = 'none';
                } else {
                    console.error("Metadata container not found, please check HTML structure");
                }

                // Check metadata content container
                const metadataContent = document.getElementById('image-metadata-content');
                if (!metadataContent) {
                    console.error("Metadata content container not found, please check HTML structure");
                }

                let username = 'default';

                // Get friendly model name display
                function getDisplayModelName(imageName) {

                    // For other names, perform general formatting
                    return imageName.split('-').map(part => {
                        // Handle number suffixes, like 7b to 7B
                        if (/^\d+[a-z]$/.test(part)) {
                            return part.slice(0, -1) + part.slice(-1).toUpperCase();
                        }
                        // Capitalize first letter
                        return part.charAt(0).toUpperCase() + part.slice(1);
                    }).join('-');
                }

                function getNameWithLatestVersion(imageName) {
                    arr = imageName.split('/');
                    let name;
                    name = (arr.length == 3) ? arr[2] : arr[1];
                    return name[0].toUpperCase() + name.slice(1).toLowerCase();
                }

                // Add function to display image metadata
                function handleImageChange() {
                    // const selectedImage = document.querySelector('select[name="master_image"]').value;
                    const selectedImage = document.getElementById('master_image').value;
                    const metadataContent = document.getElementById('image-metadata-content');
                    const metadataContainer = document.getElementById('image-metadata-container');
                    const commandInput = document.querySelector('input[name="command"]');
                    const portInput = document.querySelector('.exposed-port');
                    const statusIconsContainer = document.getElementById('status-icons-container');

                    const gpuButtons = document.querySelectorAll('.gpu-option.is-selected');
                    gpuButtons.forEach(button => {
                        button.classList.remove('is-primary', 'is-selected');
                    });

                    const nodeOptions = document.querySelectorAll('.gpu-node-option.is-selected');
                    nodeOptions.forEach(button => {
                        button.classList.remove('is-primary', 'is-selected');
                    });

                    document.getElementById('gpu-type-input').value = '';
                    document.getElementById('gpu-name-input').value = '';
                    document.getElementById('num-gpu-per-node-select').value = '-1';
                    document.getElementById('num-node-input').value = '0';

                    const gpuNodeSection = document.getElementById('gpu-node-section');
                    if (gpuNodeSection) {
                        gpuNodeSection.style.display = 'none';
                    }

                    const resourcePreview = document.getElementById('resource-allocation-preview');
                    if (resourcePreview) {
                        resourcePreview.style.display = 'none';
                    }

                    const matchStatusGoodElement = document.getElementById('match-status-good');
                    const matchStatusPoorElement = document.getElementById('match-status-poor');
                    if (matchStatusGoodElement) matchStatusGoodElement.style.display = 'none';
                    if (matchStatusPoorElement) matchStatusPoorElement.style.display = 'none';
                    if (statusIconsContainer) statusIconsContainer.style.display = 'none';

                    const nodeOptionsContainer = document.getElementById('gpu-node-options');
                    if (nodeOptionsContainer) {
                        nodeOptionsContainer.innerHTML = '';
                    }

                    // If no image is selected, hide all content and return
                    if (!selectedImage) {
                        if (metadataContent) metadataContent.innerHTML = '';
                        if (metadataContainer) metadataContainer.style.display = 'none';
                        if (commandInput) commandInput.value = '';
                        if (portInput) portInput.value = '';

                        return;
                    }

                    // Find the selected image from all image data
                    const selectedImageObj = window.imagesData.images.find(img => img.full_name === selectedImage);

                    // If the image is not found, hide all content
                    if (!selectedImageObj) {
                        if (metadataContainer) metadataContainer.style.display = 'none';
                        if (commandInput) commandInput.value = '';
                        if (portInput) portInput.value = '';

                        // Hide resource matching status icons
                        const matchStatusGoodElement = document.getElementById('match-status-good');
                        const matchStatusPoorElement = document.getElementById('match-status-poor');
                        if (matchStatusGoodElement) matchStatusGoodElement.style.display = 'none';
                        if (matchStatusPoorElement) matchStatusPoorElement.style.display = 'none';
                        if (statusIconsContainer) statusIconsContainer.style.display = 'none';

                        return;
                    }

                    const triggerDisplay = document.querySelector('.select-header-name');
                    if (selectedImageObj && triggerDisplay) {
                        triggerDisplay.textContent = getNameWithLatestVersion(selectedImage);
                    }

                    // Found the image, process image information
                    // Image name display style
                    const displayName = getDisplayModelName(selectedImageObj.name);

                    // Set default entrypoint (if exists)
                    if (commandInput) {
                        if (selectedImageObj.default_entrypoint) {
                            commandInput.value = selectedImageObj.default_entrypoint;
                        } else {
                            commandInput.value = '';
                        }
                    }

                    // Set default port (if exists)
                    if (portInput && selectedImageObj.default_port) {
                        portInput.value = selectedImageObj.default_port;
                    } else if (portInput) {
                        portInput.value = '';
                    }

                    // Set default environment variables
                    if (selectedImageObj.default_env_vars && Array.isArray(selectedImageObj.default_env_vars) && selectedImageObj.default_env_vars.length > 0) {
                        const envVarContainer = document.querySelector('.env-var-container');
                        while (envVarContainer.children.length > 1) {
                            envVarContainer.removeChild(envVarContainer.lastChild);
                        }

                        // Set first env var
                        const firstEnvVar = selectedImageObj.default_env_vars[0];
                        const firstEnvVarEl = envVarContainer.querySelector('.env-var');
                        const nameInput = firstEnvVarEl.querySelector('input[name="env_name"]');
                        const valueInput = firstEnvVarEl.querySelector('input[name="env_value"]');

                        if (nameInput && valueInput) {
                            nameInput.value = firstEnvVar.name || '';
                            valueInput.value = firstEnvVar.value || '';
                        }

                        // Add remaining env vars
                        for (let i = 1; i < selectedImageObj.default_env_vars.length; i++) {
                            const envVar = selectedImageObj.default_env_vars[i];
                            const newRow = document.createElement('div');
                            newRow.classList.add('field', 'is-grouped', 'env-var');
                            newRow.innerHTML = `
                                <div class="control is-expanded">
                                    <input class="input" type="text" name="env_name" placeholder="Variable name" value="${envVar.name || ''}">
                                </div>
                                <div class="control is-expanded">
                                    <input class="input" type="text" name="env_value" placeholder="Value" value="${envVar.value || ''}">
                                </div>
                                <div class="control">
                                    <button class="button is-danger remove_env_var"> × </button>
                                </div>
                            `;
                            envVarContainer.appendChild(newRow);

                            // Add event listener for remove button
                            const removeBtn = newRow.querySelector('.remove_env_var');
                            if (removeBtn) {
                                removeBtn.addEventListener('click', function () {
                                    envVarContainer.removeChild(newRow);
                                });
                            }
                        }
                    } else {
                        // Clear all env var inputs
                        const envVarInputs = document.querySelectorAll('.env-var input');
                        envVarInputs.forEach(input => {
                            input.value = '';
                        });
                    }

                    // Build metadata HTML
                    let metadataHTML = `<div class="metadata-title">
                        ${displayName}
                        ${selectedImageObj.github_repo ?
                            `<a href="${selectedImageObj.github_repo}" target="_blank" class="metadata-repo-link">
                                <i class="fa-brands fa-github"></i>
                            </a>` :
                            ''}
                    </div>`;

                    // Add description with Markdown support (if exists)
                    if (selectedImageObj.description) {
                        const descriptionHtml = window.converter.makeHtml(selectedImageObj.description);
                        metadataHTML += `
                        <div class="metadata-item">
                            <div class="metadata-content">${descriptionHtml}</div>
                        </div>`;
                    }

                    // Update metadata content and display
                    // metadataContent.innerHTML = metadataHTML;
                    // metadataContainer.style.display = 'block';

                    if (!selectedImageObj.description) {
                        metadataContainer.style.display = "none";
                    } else {
                        metadataContent.innerHTML = metadataHTML;
                        metadataContainer.style.display = 'block';

                    }

                    // Get current selected GPU information
                    const gpuTypeInput = document.getElementById('gpu-type-input');
                    const gpuLimitInput = document.getElementById('gpu-limit-input');
                    const gpuType = gpuTypeInput ? gpuTypeInput.value : '';
                    const gpuCount = gpuLimitInput ? parseInt(gpuLimitInput.value) || 1 : 1;

                    // Show resource allocation preview
                    const previewContainer = document.getElementById('resource-allocation-preview');
                    if (previewContainer) {
                        previewContainer.style.display = 'block';
                    }

                    // Check resource matching status
                    // Check if the image has a valid minimum_gpu_memory property
                    if (selectedImageObj.minimum_gpu_memory && selectedImageObj.minimum_gpu_memory.toString().trim() !== '') {
                        // Show matching status icons
                        if (statusIconsContainer) {
                            statusIconsContainer.style.display = 'inline-block';
                        }
                        // Update resource allocation preview
                        updateResourceAllocationPreview(selectedImageObj, gpuType, gpuCount);
                    } else {
                        // If the image does not have a valid minimum_gpu_memory property, hide matching status
                        const matchStatusGoodElement = document.getElementById('match-status-good');
                        const matchStatusPoorElement = document.getElementById('match-status-poor');

                        if (matchStatusGoodElement) matchStatusGoodElement.style.display = 'none';
                        if (matchStatusPoorElement) matchStatusPoorElement.style.display = 'none';
                        if (statusIconsContainer) statusIconsContainer.style.display = 'none';
                    }
                }


                // Process URL parameters to prefill image name, entrypoint and ports
                function processUrlParameters() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const repository = urlParams.get('repository');
                    const imageName = urlParams.get('image');
                    const tag = urlParams.get('tag');
                    const entrypoint = urlParams.get('entrypoint');
                    const ports = urlParams.get('ports');

                    if (repository && imageName && tag) {
                        const fullImageName = `${repository}/${imageName}:${tag}`;

                        // Pre-fill image name
                        window.selectedImageFromUrl = fullImageName;
                        // Pre-fill entrypoint
                        if (entrypoint) {
                            document.querySelector('input[name="command"]').value = entrypoint;
                        }
                        // Pre-fill ports
                        if (ports) {
                            try {
                                const portsObj = JSON.parse(ports);
                                // Format ports for the input field (comma-separated)
                                if (typeof portsObj === 'object') {
                                    const portsList = Object.keys(portsObj).join(',');
                                    document.querySelector('.exposed-port').value = portsList;
                                }
                            } catch (e) {
                                console.error("Error parsing ports JSON:", e);
                            }
                        }
                    }
                }

                function fetchUserInfo() {
                    api.get('/me')
                        .then(data => {
                            if (data && data.username) {
                                username = data.username;
                                document.querySelector('input[name="namespace"]').value = username;
                            }
                        })
                        .catch(error => {
                            console.error("Failed to fetch user info:", error);
                        });
                }

                // Fetch images from API and populate select box
                function fetchImages() {
                    api.get(`/me/images`)
                        .then(data => {
                            // Save all image data for later use
                            window.imagesData = data;

                            // Enhance images with metadata
                            enhanceImagesWithMetadata(data.images);

                            // Filter out images with FAILED status
                            const filteredImages = data.images.filter(image => {
                                return !image.status || !image.status.startsWith('FAILED');
                            });

                            // Categorize images into public and private
                            const publicImages = [];
                            const privateImages = [];

                            filteredImages.forEach(image => {
                                const fullName = image.full_name;
                                const arr = fullName.split('/');
                                const registry = arr[0];

                                // Check if it's a private registry (ends with "1")
                                if (registry.substr(registry.length - 1) === "1") {
                                    privateImages.push(image);
                                } else {
                                    publicImages.push(image);
                                }
                            });

                            //Get DOM elements
                            const container = document.querySelector('.options-grid');
                            const masterImageInput = document.getElementById('master_image');

                            container.innerHTML = '';

                            // Function to create image card
                            function createImageCard(image, isPrivate = false) {
                                const card = document.createElement('div');
                                card.className = 'option-card';

                                let fullName = image.full_name;
                                const name = image.display_name;

                                let status = isPrivate ? "Private" : "Public";
                                let bc = isPrivate ? "rgba(198, 40, 40, 0.05)" : "#1967d216";
                                let tc = isPrivate ? "#c62828" : "#1967d2";

                                /**-------------------------
                                 * innerHTML for card content
                                -------------------------*/
                                card.innerHTML = `
                                    <div class = "card-header"> 
                                    <div class = "tag" style = "background-color: ${bc}; color: ${tc};">${status}</div>
                                    <h4 class = "option-title">${name}</h4>
                                    ${image.github_repo ?
                                        `<a href="${image.github_repo}" target="_blank" class="metadata-repo-link"  style = "margin: 0;">
                                    <i class="fa-brands fa-github"></i>
                                    </a>` :
                                        ''}
                                    </div>
                                    <div class = "card-divider"></div>
                                    <p>${image.short_description}</p>
                                `;

                                card.addEventListener('click', () => {
                                    //remove previous selections
                                    document.querySelectorAll('.option-card').forEach(c => c.classList.remove('selected'));
                                    //Mark current card as selected
                                    card.classList.add('selected');

                                    masterImageInput.value = image.full_name;

                                    const options = document.querySelector('.image-options');
                                    options.classList.remove('visible');

                                    handleImageChange();
                                });

                                return card;
                            }

                            // Create tab structure
                            const tabsHTML = `
                                <div class="image-tabs">
                                    <button class="image-tab active" data-tab="public">
                                        Public${publicImages.length > 0 ? ` (${publicImages.length})` : ''}
                                    </button>
                                    <button class="image-tab" data-tab="private">
                                        Private${privateImages.length > 0 ? ` (${privateImages.length})` : ''}
                                    </button>
                                </div>
                                <div class="tab-content active" id="public-tab-content">
                                    <div class="options-grid" id="public-options-grid"></div>
                                </div>
                                <div class="tab-content" id="private-tab-content">
                                    <div class="options-grid" id="private-options-grid"></div>
                                </div>
                            `;

                            container.innerHTML = tabsHTML;

                            // Get tab content containers
                            const publicGrid = document.getElementById('public-options-grid');
                            const privateGrid = document.getElementById('private-options-grid');

                            // Add public images
                            if (publicImages.length > 0) {
                                publicImages.forEach(image => {
                                    const card = createImageCard(image, false);
                                    publicGrid.appendChild(card);
                                });
                            } else {
                                publicGrid.innerHTML = '<p class="has-text-grey">No public images available</p>';
                            }

                            // Add private images
                            if (privateImages.length > 0) {
                                privateImages.forEach(image => {
                                    const card = createImageCard(image, true);
                                    privateGrid.appendChild(card);
                                });
                            } else {
                                privateGrid.innerHTML = '<p class="has-text-grey">No private images available</p>';
                            }

                            // Add tab switching functionality
                            const tabs = container.querySelectorAll('.image-tab');
                            const tabContents = container.querySelectorAll('.tab-content');

                            tabs.forEach(tab => {
                                tab.addEventListener('click', () => {
                                    // Remove active class from all tabs and contents
                                    tabs.forEach(t => t.classList.remove('active'));
                                    tabContents.forEach(tc => tc.classList.remove('active'));

                                    // Add active class to clicked tab
                                    tab.classList.add('active');

                                    // Show corresponding content
                                    const targetTab = tab.dataset.tab;
                                    const targetContent = document.getElementById(`${targetTab}-tab-content`);
                                    if (targetContent) {
                                        targetContent.classList.add('active');
                                    }
                                });
                            });

                            // Check if image is pre-selected
                            if (window.selectedImageFromUrl) {
                                // Find with matching value
                                const preselectedCard = Array.from(container.querySelectorAll('.option-card')).find(card => {
                                    const cardImage = [...publicImages, ...privateImages].find(img =>
                                        img.full_name === window.selectedImageFromUrl
                                    );
                                    return cardImage && card.querySelector('.option-title').textContent === cardImage.display_name;
                                });
                                if (preselectedCard) {
                                    // Switch to appropriate tab if needed
                                    const isInPrivateTab = privateGrid.contains(preselectedCard);
                                    if (isInPrivateTab) {
                                        // Switch to private tab
                                        tabs.forEach(t => t.classList.remove('active'));
                                        tabContents.forEach(tc => tc.classList.remove('active'));
                                        document.querySelector('[data-tab="private"]').classList.add('active');
                                        document.getElementById('private-tab-content').classList.add('active');
                                    }
                                    preselectedCard.click(); // Trigger selection
                                }
                            }

                            // Set default selection if none exists - prefer public images first
                            const allCards = container.querySelectorAll('.option-card');
                            if ((!masterImageInput.value || masterImageInput.value === '') && allCards.length > 0) {
                                allCards[0].click();
                            }
                        })
                        .catch(error => {
                            console.error("Failed to fetch images:", error);
                        });
                }

                /**
                 * Trigger select options
                 */
                document.querySelector('.image-select-trigger').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const options = document.querySelector('.image-options');
                    options.classList.toggle('visible');
                });

                // Close when clicking outside
                document.addEventListener('click', function (e) {
                    const options = document.querySelector('.image-options');
                    const trigger = document.querySelector('.image-select-trigger');

                    if (!trigger.contains(e.target) && !options.contains(e.target)) {
                        options.classList.remove('visible');
                    }
                });

                // No longer need to enhance image metadata, use data directly from backend API
                function enhanceImagesWithMetadata(images) {
                    // Function kept for compatibility
                }


                // Add function to display regions
                function populateRegions() {
                    const regionContainer = document.getElementById('region-options-container');

                    // Clear existing content
                    regionContainer.innerHTML = '';

                    // Check if window.allRegions exists
                    if (window.allRegions) {
                        // Create buttons for each region
                        for (const regionCode in window.allRegions) {
                            const regionName = window.allRegions[regionCode];

                            const regionButton = document.createElement('button');
                            regionButton.classList.add('button', 'region-option', 'is-primary', 'is-selected', 'mr-2', 'mb-2');
                            regionButton.dataset.region = regionCode;
                            regionButton.textContent = regionName;
                            // Set fixed width and height for consistent button size
                            regionButton.style.width = '150px';
                            regionButton.style.height = '40px';

                            regionButton.addEventListener('click', function () {
                                // Toggle selection
                                this.classList.toggle('is-primary');
                                this.classList.toggle('is-selected');

                                // Update hidden input with all selected regions
                                updateSelectedRegions();
                            });

                            regionContainer.appendChild(regionButton);
                        }

                        // Update hidden input with all selected regions initially
                        updateSelectedRegions();
                    }
                }

                // Function to update selected regions
                function updateSelectedRegions() {
                    const selectedButtons = document.querySelectorAll('.region-option.is-selected');
                    const selectedRegions = Array.from(selectedButtons).map(button => button.dataset.region);
                    document.getElementById('selected-region-input').value = JSON.stringify(selectedRegions);

                    // Always show all GPU types.
                    document.getElementById('gpu-type-selection').style.display = 'block';
                    renderGPUTypeSelection();
                }


                // Fetch available GPU information
                function fetchGpuInfo() {
                    api.get(`/gpu-info`)
                        .then(data => {
                            window.gpuInfo = data.gpu_info || {};

                            const regionDict = {};
                            if (window.gpuInfo) {
                                for (const nodeKey in window.gpuInfo) {
                                    const node = window.gpuInfo[nodeKey];
                                    if (node.region && node.region_name) {
                                        regionDict[node.region] = node.region_name;
                                    }
                                }
                            }
                            window.allRegions = regionDict;
                        })
                        .catch(error => {
                            console.error("Failed to fetch GPU info:", error);
                        });
                }


                function renderGPUTypeSelection() {
                    const gpuContainer = document.getElementById('gpu-options-container');

                    // Store current GPU selections before updating
                    const currentSelections = new Set();
                    document.querySelectorAll('.gpu-option.is-selected').forEach(button => {
                        currentSelections.add(button.dataset.type);
                    });

                    // Get the selected regions
                    const selectedRegions = JSON.parse(document.getElementById('selected-region-input').value || '[]');

                    // Create container for GPU buttons
                    gpuContainer.classList.add('is-flex', 'is-flex-wrap-wrap');

                    // Filter GPU types based on selected regions
                    const filteredGpuTypes = {};

                    // Iterate through all GPU nodes
                    for (const nodeKey in window.gpuInfo) {
                        const node = window.gpuInfo[nodeKey];

                        // Always add this GPU type to the dictionary
                        if (!filteredGpuTypes[node.gpu_sku]) {
                            filteredGpuTypes[node.gpu_sku] = {
                                nodes: [],
                                gpu_name: node.gpu_name,
                                gpu_memory_gb: node.gpu_memory_gb,
                                total: 0,
                                used: 0
                            };
                        }

                        // Check if node's region is in selected regions
                        if (selectedRegions.includes(node.region)) {
                            filteredGpuTypes[node.gpu_sku].nodes.push(node);
                            filteredGpuTypes[node.gpu_sku].total += (node.total || 0);
                            filteredGpuTypes[node.gpu_sku].used += (node.used || 0);
                        }
                    }

                    // Create or update buttons for each GPU type
                    for (const gpuType in filteredGpuTypes) {
                        let gpuButton = document.querySelector(`.gpu-option[data-type="${gpuType}"]`);
                        const available = Math.max(0, (filteredGpuTypes[gpuType].total || 0) - (filteredGpuTypes[gpuType].used || 0));

                        if (!gpuButton) {
                            // Create new button if it doesn't exist
                            gpuButton = document.createElement('button');
                            gpuButton.classList.add('button', 'gpu-option', 'mr-2', 'mb-2');
                            gpuButton.dataset.type = gpuType;
                            gpuButton.dataset.name = filteredGpuTypes[gpuType].gpu_name || gpuType;

                            // Set fixed width and height for consistent button size
                            gpuButton.style.width = '150px';
                            gpuButton.style.height = '40px';

                            // Add click event listener
                            gpuButton.addEventListener('click', function () {
                                this.classList.toggle('is-primary');
                                this.classList.toggle('is-selected');

                                // Update hidden inputs with selected GPU types
                                updateSelectedGpuTypes();

                                // Setup GPU-node options based on selected GPU types
                                setupGpuNodeOptionsForMulti();
                            });

                            gpuContainer.appendChild(gpuButton);
                        }

                        // Only render buttons for GPU types with availability > 0
                        if (available > 0) {
                            if (!gpuButton) {
                                // Create new button if it doesn't exist
                                gpuButton = document.createElement('button');
                                gpuButton.classList.add('button', 'gpu-option', 'mr-2', 'mb-2');
                                gpuButton.dataset.type = gpuType;
                                gpuButton.dataset.name = filteredGpuTypes[gpuType].gpu_name || gpuType;

                                // Set fixed width and height for consistent button size
                                gpuButton.style.width = '150px';
                                gpuButton.style.height = '40px';

                                // Add click event listener
                                gpuButton.addEventListener('click', function () {
                                    this.classList.toggle('is-primary');
                                    this.classList.toggle('is-selected');

                                    // Update hidden inputs with selected GPU types
                                    updateSelectedGpuTypes();

                                    // Setup GPU-node options based on selected GPU types
                                    setupGpuNodeOptionsForMulti();
                                });

                                gpuContainer.appendChild(gpuButton);
                            }

                            // Update button data and text
                            gpuButton.dataset.total = filteredGpuTypes[gpuType].total || 0;
                            gpuButton.dataset.used = filteredGpuTypes[gpuType].used || 0;
                            gpuButton.textContent = `${filteredGpuTypes[gpuType].gpu_name || gpuType} (${available})`;

                            // Restore selection state
                            if (currentSelections.has(gpuType)) {
                                gpuButton.classList.add('is-primary', 'is-selected');
                            } else {
                                gpuButton.classList.remove('is-primary', 'is-selected');
                            }
                        } else if (gpuButton) {
                            // Remove button if availability is 0 and it exists
                            gpuButton.remove();
                        }
                    }

                    // Remove buttons for GPU types that no longer exist
                    document.querySelectorAll('.gpu-option').forEach(button => {
                        if (!filteredGpuTypes[button.dataset.type]) {
                            button.remove();
                        }
                    });

                    // Always show the GPU type selection section
                    gpuContainer.style.display = 'block';

                    // Check if there are any GPU buttons left
                    const gpuButtons = gpuContainer.querySelectorAll('.gpu-option');

                    // If no buttons, display a message
                    if (gpuButtons.length === 0) {
                        // Create or update the "no GPUs available" message
                        let noGpusMessage = document.getElementById('no-gpus-message');
                        if (!noGpusMessage) {
                            noGpusMessage = document.createElement('p');
                            noGpusMessage.id = 'no-gpus-message';
                            noGpusMessage.style.color = '#666'; // Optional: Style the message
                            noGpusMessage.style.fontSize = '16px';
                            noGpusMessage.style.marginTop = '10px';
                            noGpusMessage.textContent = 'Please select a region first.';
                            gpuContainer.appendChild(noGpusMessage);
                        }
                    } else {
                        // Remove the "no GPUs available" message if there are buttons
                        const noGpusMessage = document.getElementById('no-gpus-message');
                        if (noGpusMessage) {
                            noGpusMessage.remove();
                        }
                    }
                }


                // Initialize environment variable functionality
                document.getElementById('add_env_var').addEventListener('click', function () {
                    var envVarContainer = document.querySelector('.env-var-container');
                    var newEnvVar = document.createElement('div');
                    newEnvVar.classList.add('field', 'is-grouped', 'env-var');
                    newEnvVar.innerHTML = `
                        <div class="control is-expanded">
                            <input class="input" type="text" name="env_name" placeholder="Variable name">
                        </div>
                        <div class="control is-expanded">
                            <input class="input" type="text" name="env_value" placeholder="Value">
                        </div>
                        <div class="control">
                            <button class="button is-danger remove_env_var"> × </button>
                        </div>
                    `;
                    envVarContainer.append(newEnvVar);
                    newEnvVar.querySelector('.remove_env_var').addEventListener('click', function () {
                        envVarContainer.removeChild(newEnvVar);
                    });
                });

                // Form submission
                document.getElementById('submit').addEventListener('click', function () {
                    const commandValue = document.querySelector('input[name="command"]').value.trim();
                    const masterImageValue = document.getElementById('master_image').value;

                    if (!masterImageValue || masterImageValue.trim() === '') {
                        showResultModal('Warning', 'Please select a container image', 'is-warning');
                        return;
                    }

                    const selectedRegions = JSON.parse(document.getElementById('selected-region-input').value || '[]');
                    if (!selectedRegions.length) {
                        showResultModal('Warning', 'Please select at least one region', 'is-warning');
                        return;
                    }

                    const selectedGpuTypes = JSON.parse(document.getElementById('gpu-type-input').value || '[]');
                    if (!selectedGpuTypes.length) {
                        showResultModal('Warning', 'Please select at least one GPU type', 'is-warning');
                        return;
                    }

                    // Check if GPU node section exists and is visible
                    const gpuNodeSection = document.getElementById('gpu-node-section');
                    if (gpuNodeSection && gpuNodeSection.style.display !== 'none') {
                        // Only validate selection if the section is visible
                        const numGpuPerNode = parseInt(document.getElementById('num-gpu-per-node-select').value) || 0;
                        const numNode = parseInt(document.getElementById('num-node-input').value) || 0;

                        if (numGpuPerNode < 0 || numNode <= 0) {
                            showResultModal('Warning', 'Please configure GPU node settings properly', 'is-warning');
                            return;
                        }
                    }

                    const useSSH = true;
                    const portsInput = document.querySelector('.exposed-port').value.trim();
                    const exposedPorts = portsInput ?
                        portsInput.split(',').map(port => parseInt(port.trim())).filter(port => !isNaN(port)) :
                        [];

                    var data = {
                        namespace: document.querySelector('input[name="namespace"]').value || username,
                        job_name: document.querySelector('input[name="job_name"]').value || 'job',
                        master_image: masterImageValue,
                        num_node: parseInt(document.getElementById('num-node-input').value) || 0,
                        cpu_limit: 2,
                        memory_limit: '10Gi',
                        num_gpu_per_node: parseInt(document.getElementById('num-gpu-per-node-select').value) || 0,
                        commandArray: commandValue ? commandValue.split(/\s+/).map(arg => arg.trim()) : [],
                        env_vars: [],
                        use_ssh: useSSH,
                        gpu_type: selectedGpuTypes,
                        exposed_ports: exposedPorts,
                        regions: selectedRegions,
                    };

                    document.querySelectorAll('.env-var').forEach(function (row) {
                        const name = row.querySelector('input[name="env_name"]').value;
                        const value = row.querySelector('input[name="env_value"]').value;
                        if (name) {
                            data.env_vars.push({
                                name: name,
                                value: value
                            });
                        }
                    });

                    // Create confirm dialog content
                    let confirmContent = `
                    <div class="modal is-active">
                        <div class="modal-background"></div>
                        <div class="modal-card">
                            <header class="modal-card-head">
                                <p class="modal-card-title">Confirm Job Creation</p>
                                <button class="delete close-modal" aria-label="close"></button>
                            </header>
                            <section class="modal-card-body">
                                <div class="content">
                                    <h4>Job Configuration</h4>
                                    <table class="table is-fullwidth">
                                        <tbody>
                                            <tr><td>Namespace:</td><td>${data.namespace}</td></tr>
                                            <tr><td>Job Name:</td><td>${data.job_name}</td></tr>
                                            <tr><td>Image:</td><td>${data.master_image}</td></tr>
                                            <tr><td>GPU Type:</td><td>${document.getElementById('gpu-name-input').value}</td></tr>
                                            <tr><td>Region:</td><td>${data.regions.map(regionCode => window.allRegions[regionCode] || regionCode).join(', ')}</td></tr>
                                            <tr><td>GPU Count:</td><td>${data.num_gpu_per_node}</td></tr>
                                            <tr><td>node Count:</td><td>${data.num_node}</td></tr>
                                            <tr><td>CPU Limit:</td><td>${data.cpu_limit} cores</td></tr>
                                            <tr><td>Memory Limit:</td><td>${data.memory_limit}</td></tr>
                                            <tr><td>Command:</td><td>${data.commandArray.length > 0 ? data.commandArray.join(' ') : 'None (SSH mode)'}</td></tr>
                                            <tr><td>SSH Mode:</td><td>${data.use_ssh ? 'Enabled' : 'Disabled'}</td></tr>
                                            <tr><td>Exposed Ports:</td><td>${data.exposed_ports.length > 0 ? data.exposed_ports.join(', ') : 'None'}</td></tr>
                                        </tbody>
                                    </table>
                                    ${data.env_vars.length > 0 ? `
                                    <h4>Environment Variables</h4>
                                    <table class="table is-fullwidth">
                                        <thead>
                                            <tr><th>Name</th><th>Value</th></tr>
                                        </thead>
                                        <tbody>
                                            ${data.env_vars.map(env => `<tr><td>${env.name}</td><td>${env.value}</td></tr>`).join('')}
                                        </tbody>
                                    </table>
                                    ` : ''}
                                </div>
                            </section>
                            <footer class="modal-card-foot">
                                <button class="button is-primary confirm-create">Confirm</button>
                                <button class="button close-modal">Cancel</button>
                            </footer>
                        </div>
                    </div>
                    `;

                    // Add confirm dialog to page
                    const confirmModal = document.createElement('div');
                    confirmModal.innerHTML = confirmContent;
                    document.body.appendChild(confirmModal);

                    // Handle close button
                    document.querySelectorAll('.close-modal').forEach(btn => {
                        btn.addEventListener('click', function () {
                            document.body.removeChild(confirmModal);
                        });
                    });

                    // Handle confirm button
                    document.querySelector('.confirm-create').addEventListener('click', function () {
                        // Remove confirm dialog
                        document.body.removeChild(confirmModal);

                        console.log('Creating job with data:', data);

                        // Send API request to create job
                        api.post(`/me/create-job-multi`, data)
                            .then(result => {
                                showResultModal('Success', 'Job created successfully!', 'is-success', function () {
                                    window.location.href = '/';
                                });
                            })
                            .catch(error => {
                                console.error('Error creating job:', error);

                                let errorMessage = 'Failed to create job';
                                let errorDetails = '';

                                if (error.message) {
                                    errorMessage = error.message;
                                }

                                if (error.details) {
                                    if (typeof error.details === 'string') {
                                        try {
                                            const detailsObj = JSON.parse(error.details);

                                            if (detailsObj.message) {
                                                errorDetails = detailsObj.message;
                                            } else if (detailsObj.details && detailsObj.details.causes) {
                                                const causes = detailsObj.details.causes;
                                                if (causes && causes.length > 0) {
                                                    errorDetails = causes.map(cause =>
                                                        `${cause.field}: ${cause.message}`).join('\n');
                                                }
                                            }
                                        } catch (e) {
                                            errorDetails = error.details;
                                        }
                                    } else if (typeof error.details === 'object') {
                                        if (error.details.message) {
                                            errorDetails = error.details.message;
                                        }
                                    }
                                }

                                if (!errorDetails && error.response) {
                                    try {
                                        const responseData = JSON.parse(error.response);
                                        if (responseData.message) {
                                            if (errorMessage === 'Failed to create job') {
                                                errorMessage = responseData.message;
                                            } else {
                                                errorDetails = responseData.message;
                                            }
                                        }
                                    } catch (e) {
                                        errorDetails = error.response;
                                    }
                                }

                                let fullErrorMessage = errorMessage;
                                if (errorDetails && !errorMessage.includes(errorDetails)) {
                                    fullErrorMessage += `\n\n${errorDetails}`;
                                }

                                showResultModal('Error', fullErrorMessage, 'is-danger');
                            });
                    });
                });

                // Initialize page
                // Change: Load GPU information first, then load image information
                fetchGpuInfo();
                fetchUserInfo();
                fetchImages();
                processUrlParameters();

                // Check if gpuInfo is already loaded
                if (window.gpuInfo) {
                    populateRegions();
                } else {
                    // Wait for GPU info to be loaded
                    const checkGpuInfoInterval = setInterval(function () {
                        if (window.allRegions) {
                            clearInterval(checkGpuInfoInterval);
                            populateRegions();
                        }
                    }, 500);
                }
            }); // DOMContentLoaded end!!!


            // Check resource matching status
            function updateResourceMatchingStatus(selectedImageObj) {
                // Get match status elements
                const matchStatusGoodElement = document.getElementById('match-status-good');
                const matchStatusPoorElement = document.getElementById('match-status-poor');
                const statusIconsContainer = document.getElementById('status-icons-container');

                // Hide match status by default
                if (matchStatusGoodElement) matchStatusGoodElement.style.display = 'none';
                if (matchStatusPoorElement) matchStatusPoorElement.style.display = 'none';

                // Check if the image has a valid minimum_gpu_memory property
                if (!selectedImageObj || !selectedImageObj.minimum_gpu_memory || selectedImageObj.minimum_gpu_memory.toString().trim() === '') {
                    // Hide matching status icons
                    if (statusIconsContainer) {
                        statusIconsContainer.style.display = 'none';
                    }
                    return;
                }

                // Show matching status icons   
                if (statusIconsContainer) {
                    statusIconsContainer.style.display = 'inline-block';
                }

                // Get image's minimum GPU memory requirement by the image
                let minimumGpuMemory = 0;
                if (selectedImageObj.minimum_gpu_memory) {
                    if (!isNaN(selectedImageObj.minimum_gpu_memory)) {
                        minimumGpuMemory = parseInt(selectedImageObj.minimum_gpu_memory);
                    } else if (typeof selectedImageObj.minimum_gpu_memory === 'string') {
                        const memoryMatch = selectedImageObj.minimum_gpu_memory.match(/(\d+)/);
                        if (memoryMatch) {
                            minimumGpuMemory = parseInt(memoryMatch[1]);
                        }
                    }
                }

                // Since we're not checking GPU type and count, we'll just show the requirements
                if (minimumGpuMemory > 0) {
                    // Show the minimum requirements without comparing to selected resources
                    if (matchStatusGoodElement) matchStatusGoodElement.style.display = 'inline-flex';
                }
            }


            // Function to update hidden inputs with selected GPU types
            function updateSelectedGpuTypes() {
                const selectedButtons = document.querySelectorAll('.gpu-option.is-selected');
                const selectedTypes = Array.from(selectedButtons).map(button => button.dataset.type);
                const selectedNames = Array.from(selectedButtons).map(button => button.dataset.name);

                document.getElementById('gpu-type-input').value = JSON.stringify(selectedTypes);
                document.getElementById('gpu-name-input').value = selectedNames.join(', ');

                const gpuNodeSection = document.getElementById('gpu-node-section');
                if (selectedButtons.length > 0) {
                    gpuNodeSection.style.display = 'block';
                } else {
                    gpuNodeSection.style.display = 'none';
                }
                updateNodeMaxCount();
                updateConfiguration();
            }


            // Function to setup GPU-node options based on selected GPU types
            function setupGpuNodeOptionsForMulti() {
                const selectedButtons = document.querySelectorAll('.gpu-option.is-selected');
                const selectedTypes = Array.from(selectedButtons).map(button => button.dataset.type);

                // Hide GPU node section if no GPUs are selected
                if (selectedButtons.length === 0) {
                    const container = document.getElementById('gpu-node-section');
                    document.getElementById('resource-allocation-preview').style.display = 'none';
                    container.style.display = 'none';
                    return;
                }

                // Show GPU node section when GPUs are selected
                document.getElementById('gpu-node-section').style.display = 'block';

                // Initialize variables for GPU availability tracking
                let totalAvailableGPUs = 0;
                let maxGpusPerNode = 0;
                let minGpusPerNode = Infinity;
                let hasEnabledOption = false;

                // Calculate available GPUs from GPU info
                if (window.gpuInfo) {
                    for (const nodeKey in window.gpuInfo) {
                        const node = window.gpuInfo[nodeKey];
                        if (selectedTypes.includes(node.gpu_sku)) {
                            const nodeAvailableGPUs = Math.max(0, (node.total || 0) - (node.used || 0));
                            maxGpusPerNode = Math.max(maxGpusPerNode, nodeAvailableGPUs);
                            minGpusPerNode = Math.min(minGpusPerNode, nodeAvailableGPUs);
                        }
                    }
                }

                // Handle case where no GPUs are available
                if (minGpusPerNode === Infinity) {
                    minGpusPerNode = 0;
                }

                // Calculate total available GPUs across all selected types
                selectedButtons.forEach((button, index) => {
                    const totalGPUs = parseInt(button.dataset.total) || 0;
                    const usedGPUs = parseInt(button.dataset.used) || 0;
                    const availableGPUs = Math.max(0, totalGPUs - usedGPUs);

                    totalAvailableGPUs += availableGPUs;
                });

                // Get references to form elements
                const gpuSelectElement = document.getElementById('num-gpu-per-node-select');
                const nodeInput = document.getElementById('num-node-input');

                // Set up event listeners for GPU and node inputs
                gpuSelectElement.addEventListener('change', function () {
                    // Reset node input when GPU selection changes
                    nodeInput.value = 1;
                    updateConfiguration();
                });

                nodeInput.addEventListener('input', updateConfiguration);

                // Initialize configuration if GPUs are available
                if (totalAvailableGPUs > 0) {
                    hasEnabledOption = true;
                    updateConfiguration();

                    // Update resource matching status based on selected image
                    const selectedImageInput = document.getElementById('master_image');
                    if (selectedImageInput && selectedImageInput.value) {
                        const selectedImageObj = window.imagesData && window.imagesData.images ?
                            window.imagesData.images.find(img => img.full_name === selectedImageInput.value) : null;
                        if (selectedImageObj) {
                            updateResourceMatchingStatus(selectedImageObj, parseInt(gpuSelectElement.value));
                        }
                    }
                }

                // Reset resource preview and status indicators
                const resourcePreview = document.getElementById('resource-allocation-preview');
                const matchStatusGood = document.getElementById('match-status-good');
                const matchStatusPoor = document.getElementById('match-status-poor');

                if (resourcePreview) resourcePreview.style.display = 'none';
                if (matchStatusGood) matchStatusGood.style.display = 'none';
                if (matchStatusPoor) matchStatusPoor.style.display = 'none';

                // Select first available option if any are enabled
                if (hasEnabledOption) {
                    const container = document.getElementById('gpu-node-section');
                    if (container) {
                        for (let i = 0; i < container.children.length; i++) {
                            const button = container.children[i];
                            if (!button.disabled) {
                                button.click();
                                break;
                            }
                        }

                        // Update resource matching status for selected image
                        const selectedImageInput = document.getElementById('master_image');
                        if (selectedImageInput && selectedImageInput.value) {
                            const selectedImageObj = window.imagesData && window.imagesData.images ?
                                window.imagesData.images.find(img => img.full_name === selectedImageInput.value) : null;
                            if (selectedImageObj) {
                                const firstEnabledOption = Array.from(container.children).find(btn => !btn.disabled);
                                const gpuCount = firstEnabledOption ? parseInt(firstEnabledOption.dataset.gpus) || 1 : 1;
                                updateResourceMatchingStatus(selectedImageObj, gpuCount);
                            }
                        }
                    }
                }
            }

            function calculateMaxNodes() {
                const gpuSelectElement = document.getElementById('num-gpu-per-node-select');
                const gpusPerNode = parseInt(gpuSelectElement.value);

                // Calculate total available GPUs from selected options
                const selectedButtons = document.querySelectorAll('.gpu-option.is-selected');
                let totalAvailableGPUs = 0;

                selectedButtons.forEach((button) => {
                    const totalGPUs = parseInt(button.dataset.total) || 0;
                    const usedGPUs = parseInt(button.dataset.used) || 0;
                    const availableGPUs = Math.max(0, totalGPUs - usedGPUs);
                    totalAvailableGPUs += availableGPUs;
                });

                // Calculate maximum possible nodes based on available GPUs
                return gpusPerNode > 0 ? Math.floor(totalAvailableGPUs / gpusPerNode) : 10;
            }

            function updateNodeMaxCount() {
                // console.log('updateNodeMaxCount is called');
                const nodeInput = document.getElementById('num-node-input');
                const maxNodes = calculateMaxNodes();

                // Update the max attribute of the input element
                nodeInput.setAttribute('max', maxNodes);

                // Adjust node count if it exceeds the new maximum
                if (parseInt(nodeInput.value) > maxNodes) {
                    nodeInput.value = maxNodes;
                }

                // Validate the input
                validateNodeInput(nodeInput);
            }

            function validateNodeInput(input) {
                // console.log('validateNodeInput is called');
                const value = parseInt(input.value);
                const max = parseInt(input.getAttribute('max'));
                const min = parseInt(input.getAttribute('min'));
                const gpuLimitWarning = document.getElementById('gpu-limit-warning');
                const nodeLimitWarning = document.getElementById('node-limit-warning');

                // Hide all warnings by default
                gpuLimitWarning.style.display = 'none';
                nodeLimitWarning.style.display = 'none';

                // Validate input value against min/max constraints
                if (isNaN(value) || value < min) {
                    input.value = min;
                    nodeLimitWarning.style.display = 'block';
                } else if (value > max) {
                    input.value = max;
                    gpuLimitWarning.style.display = 'block';
                }

                // Update configuration based on new input
                updateConfiguration();
            }

            function updateConfiguration() {
                const gpuSelectElement = document.getElementById('num-gpu-per-node-select');
                const nodeInput = document.getElementById('num-node-input');
                const gpuLimitWarning = document.getElementById('gpu-limit-warning');
                const nodeLimitWarning = document.getElementById('node-limit-warning');

                const gpusPerNode = parseInt(gpuSelectElement.value);
                let nodeCount = parseInt(nodeInput.value);

                // Get maximum possible nodes
                const maxNodes = calculateMaxNodes();

                // Hide warnings by default
                gpuLimitWarning.style.display = 'none';
                nodeLimitWarning.style.display = 'none';

                // Validate node count and show appropriate warnings
                if (isNaN(nodeCount) || nodeCount < 1) {
                    nodeCount = 1;
                    nodeInput.value = 1;
                    nodeLimitWarning.style.display = 'block';
                } else if (nodeCount > maxNodes) {
                    nodeCount = maxNodes;
                    nodeInput.value = maxNodes;
                    gpuLimitWarning.style.display = 'block';
                }

                // Update hidden form fields with current configuration
                const hiddenGpuInput = document.getElementById('num-gpu-per-node-select');
                if (hiddenGpuInput) {
                    hiddenGpuInput.value = gpusPerNode;
                }

                // No need to update nodeInput again as we already set it above

                // Update the resource allocation preview
                updateResourceAllocationPreview(gpusPerNode, nodeCount);
            }


            // Function to update the resource allocation preview
            function updateResourceAllocationPreview(gpuCount, nodeCount) {
                const previewContainer = document.getElementById('resource-allocation-preview');

                // Get selected GPU information
                let cpuCoresPerGpu = 0;
                let memoryGbPerGpu = 0;

                // Calculate total resources
                const totalCpuCores = (cpuCoresPerGpu * gpuCount * nodeCount).toFixed(1);
                const totalMemoryGb = (memoryGbPerGpu * gpuCount * nodeCount).toFixed(1);

                // Update preview information
                const gpuValueText = `${gpuCount} GPUs × ${nodeCount} Nodes`;

                document.getElementById('preview-gpu-info').textContent = gpuValueText;
                document.getElementById('preview-cpu-info').textContent = `${totalCpuCores} cores (automatically assigned)`;
                document.getElementById('preview-memory-info').textContent = `${totalMemoryGb}Gi (automatically assigned)`;

                // Show preview container
                previewContainer.style.display = 'block';

                // Get current selected image
                // const selectedImage = document.querySelector('select[name="master_image"]').value;
                const selectedImage = document.getElementById('master_image').value;

                // Get match status elements
                const matchStatusGoodElement = document.getElementById('match-status-good');
                const matchStatusPoorElement = document.getElementById('match-status-poor');

                // Hide match status by default
                matchStatusGoodElement.style.display = 'none';
                matchStatusPoorElement.style.display = 'none';

                // If no image selected, don't perform resource matching analysis
                if (!selectedImage) {
                    return;
                }

                // Find selected image metadata
                const selectedImageData = window.imagesData && window.imagesData.images ?
                    window.imagesData.images.find(img => img.full_name === selectedImage) : null;

                // If the image does not have the minimum_gpu_memory property, hide matching status
                if (!selectedImageData || !selectedImageData.minimum_gpu_memory || selectedImageData.minimum_gpu_memory.toString().trim() === '') {
                    matchStatusGoodElement.style.display = 'none';
                    matchStatusPoorElement.style.display = 'none';

                    const statusIconsContainer = document.getElementById('status-icons-container');
                    if (statusIconsContainer) statusIconsContainer.style.display = 'none';

                    return;
                } else {
                    // Show matching status icons
                    const statusIconsContainer = document.getElementById('status-icons-container');
                    if (statusIconsContainer) statusIconsContainer.style.display = 'inline-block';
                }
            }




            // Add a generic result display modal function
            function showResultModal(title, message, colorClass, callback) {
                const resultModalContent = `
                <div class="modal is-active">
                    <div class="modal-background"></div>
                    <div class="modal-card">
                        <header class="modal-card-head ${colorClass}">
                            <p class="modal-card-title">${title}</p>
                            <button class="delete close-result-modal" aria-label="close"></button>
                        </header>
                        <section class="modal-card-body">
                            <div class="content">
                                <p>${message}</p>
                            </div>
                        </section>
                        <footer class="modal-card-foot">
                            <button class="button ${colorClass} close-result-modal">OK</button>
                        </footer>
                    </div>
                </div>
                `;

                const resultModal = document.createElement('div');
                resultModal.innerHTML = resultModalContent;
                document.body.appendChild(resultModal);

                // Handle close button
                document.querySelectorAll('.close-result-modal').forEach(btn => {
                    btn.addEventListener('click', function () {
                        document.body.removeChild(resultModal);
                        if (typeof callback === 'function') {
                            callback();
                        }
                    });
                });
            }

            //Collapsable advanced options section

            document.addEventListener('DOMContentLoaded', function () {

                const arrowBtn = document.getElementById('collapse-arrow-btn');
                const content = document.getElementById('advanced-options-content');
                // Make both the header and arrow clickable
                document.getElementById('advanced-options-header').addEventListener('click', function (e) {
                    // Prevent double toggle if clicking arrow button
                    if (e.target === arrowBtn || arrowBtn.contains(e.target)) return;
                    arrowBtn.click();
                });
                arrowBtn.addEventListener('click', function () {
                    const expanded = arrowBtn.getAttribute('aria-expanded') === 'true';
                    arrowBtn.setAttribute('aria-expanded', String(!expanded));
                    if (expanded) {
                        content.classList.remove('show');
                        content.setAttribute('hidden', '');
                    } else {
                        content.classList.add('show');
                        content.removeAttribute('hidden');
                    }
                });
            });

        </script>


        <div class="container main-form">
            <div class="columns is-multiline">
                <div class="column is-12">
                    <h1 class="title">Create Job</h1>
                    <h2 class="subtitle">Select container image and configuration</h2>
                </div>
            </div>

            <!-- Image Selection -->
            <div class="form-section">
                <h3 class="section-title">Image Selection</h3>
                <div class="field">
                    <label class="label">Container Image</label>
                    <div class="control">
                        <input type="hidden" id="master_image" name="master_image">

                        <!--Trigger button-->
                        <div class="image-select-trigger">
                            <div class="select-header">
                                <span class="select-header-name">Select an image ...</span>
                                <span class="dropdown-icon"><i class="fa-solid fa-caret-down"></i></span>
                            </div>
                        </div>

                        <div class="image-options">
                            <div class="options-grid">

                            </div>
                        </div>
                    </div>
                </div>

                <!-- Image metadata display area -->
                <div id="image-metadata-container" style="display: none;">
                    <div id="image-metadata-content" class="content markdown-body"></div>
                </div>
            </div>

            <!-- Basic Information -->
            <div class="form-section">
                <h3 class="section-title">Basic Configuration</h3>
                <div class="columns">
                    <div class="column is-8 field">
                        <label class="label">Job Name</label>
                        <div class="control">
                            <input class="input" type="text" name="job_name" value="job" placeholder="job">
                        </div>
                    </div>
                    <div class="column is-4 field">
                        <label class="label">Namespace</label>
                        <div class="control">
                            <input class="input" type="text" name="namespace" placeholder="Set automatically">
                        </div>
                    </div>

                </div>
                <h3 class="section-title">GPU Configuration</h3>

                <div class="field">
                    <div id="gpu-type-selection" class="field" style="display: none;">
                        <!-- <label class="label">Available GPU Types for Selection</label> -->
                        <div class="control">
                            <div id="gpu-options-container" class="buttons gpu-buttons-container"></div>
                            <input type="hidden" id="gpu-type-input" name="gpu_type" value="">
                            <input type="hidden" id="gpu-name-input" name="gpu_name" value="">
                        </div>
                    </div>

                    <!-- The regioin label -->
                    <div class="control">
                        <button id="toggle-region-selection" class="button is-small mb-2 borderless-button"
                            style="border: none !important;">
                            <span class="icon">
                                <i class="fas fa-chevron-right"></i>
                            </span>
                            <span>Regions</span>
                        </button>
                        <div id="region-options-container" class="buttons region-buttons-container"
                            style="display: none;">
                        </div>
                        <input type="hidden" id="selected-region-input" name="selected_region" value="[]">
                        <script>
                            document.getElementById('toggle-region-selection').addEventListener('click', function () {
                                const container = document.getElementById('region-options-container');
                                const icon = this.querySelector('.icon i');
                                const text = this.querySelector('span:not(.icon)');

                                if (container.style.display === 'none') {
                                    container.style.display = 'flex';
                                    icon.classList.remove('fa-chevron-right');
                                    icon.classList.add('fa-chevron-down');
                                    text.textContent = 'Regions';
                                } else {
                                    container.style.display = 'none';
                                    icon.classList.remove('fa-chevron-down');
                                    icon.classList.add('fa-chevron-right');
                                    text.textContent = 'Regions';
                                }
                            });
                        </script>
                    </div>

                    <!-- GPU and node number input -->
                    <div id="gpu-node-section" class="field" style="display: none;">
                        <!-- <label class="label">GPU and Node Configuration</label> -->
                        <div class="control">
                            <div class="field is-horizontal">
                                <div class="field-body">
                                    <div class="field">
                                        <label class="label">GPUs per Node: </label>
                                        <div class="control">
                                            <div class="select">
                                                <select id="num-gpu-per-node-select" name="num_gpu_per_node"
                                                    onchange="updateNodeMaxCount()">
                                                    <option value="0">0 GPU</option>
                                                    <option value="1">1 GPU</option>
                                                    <option value="2">2 GPUs</option>
                                                    <option value="4">4 GPUs</option>
                                                    <option value="8">8 GPUs</option>
                                                </select>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="field">
                                        <label class="label">Number of Nodes: </label>
                                        <div class="control">
                                            <input id="num-node-input" class="input" type="number" name="num_node"
                                                min="0" max="1" oninput="validateNodeInput(this)" defaultValue="0">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <p id="gpu-limit-warning" class="help is-danger" style="display: none;">
                                The total number of GPUs exceeds the available limit.
                            </p>
                            <p id="node-limit-warning" class="help is-danger" style="display: none;">
                                Please enter a valid number of nodes between 0 and the maximum available.
                            </p>
                        </div>


                        <!-- Resource Allocation Preview -->
                        <div id="resource-allocation-preview" class="mt-4" style="display: none;">
                            <label class="label">Resource Allocation Preview</label>
                            <div class="box has-background-white-ter">
                                <div class="resource-preview-grid">
                                    <div class="resource-item">
                                        <span class="icon-text">
                                            <span class="icon has-text-info">
                                                <i class="fas fa-microchip"></i>
                                            </span>
                                            <span class="has-text-weight-medium">
                                                GPU
                                                <span id="status-icons-container" class="status-icons-container"
                                                    style="display: inline-block;">
                                                    <span id="match-status-good" class="match-status good">
                                                        <i class="fas fa-check-circle" data-tooltip="Good"></i>
                                                    </span>
                                                    <span id="match-status-poor" class="match-status poor">
                                                        <i class="fas fa-exclamation-circle"
                                                            data-tooltip="Below Requirements"></i>
                                                    </span>
                                                </span>:
                                            </span>
                                        </span>
                                        <span id="preview-gpu-info" class="resource-value">-</span>
                                    </div>
                                    <div class="resource-item">
                                        <span class="icon-text">
                                            <span class="icon has-text-success">
                                                <i class="fas fa-cog"></i>
                                            </span>
                                            <span class="has-text-weight-medium">CPU:</span>
                                        </span>
                                        <span id="preview-cpu-info" class="resource-value">-</span>
                                    </div>
                                    <div class="resource-item">
                                        <span class="icon-text">
                                            <span class="icon has-text-warning">
                                                <i class="fas fa-memory"></i>
                                            </span>
                                            <span class="has-text-weight-medium">Memory:</span>
                                        </span>
                                        <span id="preview-memory-info" class="resource-value">-</span>
                                    </div>
                                    <div class="resource-item">
                                        <span class="icon-text">
                                            <span class="icon has-text-primary">
                                                <i class="fas fa-hdd"></i>
                                            </span>
                                            <span class="has-text-weight-medium">Storage:</span>
                                        </span>
                                        <span id="preview-storage-info" class="resource-value">100GB temporary
                                            storage</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Resource Matching Analysis section - same level as Resource Allocation Preview -->
                        <div id="resource-matching-analysis" class="mt-4" style="display: none;">
                            <label class="label">Resource Matching Analysis</label>
                            <div class="box has-background-white-ter">
                                <div class="resource-match-item">
                                    <div class="resource-match-label">
                                        Current Model
                                        <span id="model-name">Resource Match:</span>
                                        <span id="match-status" class="match-status good">Good</span>
                                    </div>
                                </div>

                                <div class="resource-match-item">
                                    <div class="resource-match-label">Estimated Memory Usage:</div>
                                    <div class="progress-bar-container">
                                        <div id="memory-usage-bar" class="progress-bar memory" style="width: 62.5%;">
                                        </div>
                                    </div>
                                    <div class="usage-info">
                                        <span id="memory-usage-text">~40GB/64GB</span>
                                        <span id="memory-usage-percent">62.5%</span>
                                    </div>
                                </div>

                                <div class="resource-match-item">
                                    <div class="resource-match-label">Estimated GPU Utilisation:</div>
                                    <div class="progress-bar-container">
                                        <div id="gpu-usage-bar" class="progress-bar gpu" style="width: 85%;"></div>
                                    </div>
                                    <div class="usage-info">
                                        <span></span>
                                        <span id="gpu-usage-percent">~85%</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="entrypoint-section" class="field">
                    <label class="label includes-i">
                        Entry Command (Leaving empty will retain only the SSH connection.)

                        <i class="fa-solid fa-circle-info"
                            data-tooltip="If you specify an entry command, it will be used as the main process in the container. Leave this blank to launch only the SSH service."></i>
                    </label>
                    <div class="control">
                        <input class="input" type="text" name="command" value="" placeholder="e.g.: /usr/sbin/sshd -D">
                    </div>
                </div>

            </div>




            <!-- Advanced Options -->
            <div class="form-section">

                <div class="section-header" id="advanced-options-header">
                    <h3 class="collapsable-section-title">Advanced Options</h3>

                    <button class="collapse-arrow" aria-expanded="false" aria-controls="advanced-options-content"
                        id="collapse-arrow-btn" type="button" tabindex="0" aria-label="Toggle advanced options">
                        <!-- Right-pointing arrow SVG (chevron) -->
                        <svg viewBox="0 0 20 20">
                            <polyline points="6,4 14,10 6,16" stroke="currentColor" stroke-width="2.2" fill="none"
                                stroke-linecap="round" stroke-linejoin="round" />
                        </svg>
                    </button>

                </div>

                <div class="collapsible-content" id="advanced-options-content" aria-labelledby="advanced-options-header"
                    hidden>
                    <!-- Exposed Ports -->
                    <div class="field">
                        <label class="label includes-i">Exposed Ports <i class="fa-solid fa-circle-info"
                                data-tooltip="Exposed ports are network ports that your application makes available to accept connections from outside the container. Specify which ports should be accessible for services like web servers, SSH, or APIs."></i>
                        </label></label>
                        <div class="control">
                            <input class="input exposed-port" type="text"
                                placeholder="Comma-separated ports (e.g.: 22,80,8080)">
                        </div>
                    </div>

                    <!-- SSH Option - hidden, handled by code logic -->
                    <div id="ssh-section" class="field" style="display: none;">
                        <label class="label">Enable SSH</label>
                        <div class="control">
                            <input type="checkbox" name="use_ssh" style="width: 20px; height: 20px;">
                        </div>
                    </div>

                    <!-- Environment Variables -->
                    <label class="label includes-i">Environment Variables <i class="fa-solid fa-circle-info"
                            data-tooltip="Environment variables are key-value settings that programs can use at runtime to configure applications without changing code."></i>
                    </label>
                    <div class="field env-var-container">
                        <div class="field is-grouped env-var">
                            <div class="control is-expanded">
                                <input class="input" type="text" name="env_name" placeholder="Variable name">
                            </div>
                            <div class="control is-expanded">
                                <input class="input" type="text" name="env_value" placeholder="Value">
                            </div>
                            <div class="control">
                                <button class="button is-primary" id="add_env_var">＋</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Submit Button -->
            <div class="field submit">
                <div class="control">
                    <button class="button primary is-medium" id="submit">Launch</button>
                </div>
            </div>
    </section>

    <sing-footer></sing-footer>
    <!-- <footer class="section footer">
        <div class="container">
            <div class="columns content">
                <div class="column items is-3">
                    <div class="item item-title">TACC Workflow</div>
                    <div class="item">Launch & Monitor AI Jobs</div>
                    <div class="item">Access Cloud Storage</div>
                    <div class="item">Manage Code & Scripts</div>
                </div>
                <div class="column items is-3">
                    <div class="item item-title">TACC Space</div>
                    <div class="item">Latest Public Images</div>
                    <div class="item">Public Dataset</div>
                    <div class="item">Discussion Groups</div>
                </div>
                <div class="column items is-3">
                    <div class="item item-title">Research</div>
                    <div class="item">AI-centric Networking</div>
                    <div class="item">Machine Learning Systems</div>
                    <div class="item">Cluster Resource Scheduling</div>
                </div>
                <div class="column items is-3">
                    <div class="item item-title">Company</div>
                    <div class="item">Our Team</div>
                    <div class="item">Careers</div>
                    <div class="item">HKUST iSING Lab</div>
                </div>
            </div>
            <div class="columns is-align-items-center">
                <div class="column is-narrow logo"><img src="assets/tacc-logo.png" /></div>
                <div class="column copyright is-narrow"><span class="text-colored">星畅</span> © 2020–2024</div>
            </div>
        </div>
    </footer> -->
</body>

</html>